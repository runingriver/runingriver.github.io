
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>【转】计算机操作系统 | running river</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="奔跑的小河">
    

    
    <meta name="description" content="第一章 概述 操作系统基本特征 1. 并发 2. 共享 3. 虚拟 4. 异步   系统调用 中断分类 1. 外中断 2. 异常 3. 陷入   大内核和微内核 1. 大内核 2. 微内核     第二章 进程管理 进程与线程 1. 进程 2. 线程 3. 区别   进程状态的切换 调度算法 1. 批处理系统中的调度 ">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="【转】计算机操作系统">
<meta property="og:url" content="http://huzongzhe.cn/2017/03/01/【转】计算机操作系统/index.html">
<meta property="og:site_name" content="running river">
<meta property="og:description" content="第一章 概述 操作系统基本特征 1. 并发 2. 共享 3. 虚拟 4. 异步   系统调用 中断分类 1. 外中断 2. 异常 3. 陷入   大内核和微内核 1. 大内核 2. 微内核     第二章 进程管理 进程与线程 1. 进程 2. 线程 3. 区别   进程状态的切换 调度算法 1. 批处理系统中的调度 1.1 先来先服务 1.2 短作业优先 1.3 最短剩余时间优先   2.">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://huzongzhe.cn/images/1706ce58-a081-4fed-9b36-c3c0d7e22b3a.jpg">
<meta property="og:image" content="http://huzongzhe.cn/images/042cf928-3c8e-4815-ae9c-f2780202c68f.png">
<meta property="og:image" content="http://huzongzhe.cn/images/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg">
<meta property="og:image" content="http://huzongzhe.cn/images/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png">
<meta property="og:image" content="http://huzongzhe.cn/images/ed523051-608f-4c3f-b343-383e2d194470.png">
<meta property="og:image" content="http://huzongzhe.cn/images/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png">
<meta property="og:image" content="http://huzongzhe.cn/images/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png">
<meta property="og:image" content="http://huzongzhe.cn/images/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png">
<meta property="og:image" content="http://huzongzhe.cn/images/22de0538-7c6e-4365-bd3b-8ce3c5900216.png">
<meta property="og:image" content="http://huzongzhe.cn/images/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png">
<meta property="og:image" content="http://huzongzhe.cn/images/eb859228-c0f2-4bce-910d-d9f76929352b.png">
<meta property="og:updated_time" content="2018-03-12T06:22:12.696Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【转】计算机操作系统">
<meta name="twitter:description" content="第一章 概述 操作系统基本特征 1. 并发 2. 共享 3. 虚拟 4. 异步   系统调用 中断分类 1. 外中断 2. 异常 3. 陷入   大内核和微内核 1. 大内核 2. 微内核     第二章 进程管理 进程与线程 1. 进程 2. 线程 3. 区别   进程状态的切换 调度算法 1. 批处理系统中的调度 1.1 先来先服务 1.2 短作业优先 1.3 最短剩余时间优先   2.">
<meta name="twitter:image" content="http://huzongzhe.cn/images/1706ce58-a081-4fed-9b36-c3c0d7e22b3a.jpg">

    
    <link rel="alternative" href="/atom.xml" title="running river" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="running river" title="running river"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="running river">running river</a></h1>
				<h2 class="blog-motto">生命不止，奔跑不息</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页|Home</a></li>
					
						<li><a href="/archives">归档|Archives</a></li>
					
						<li><a href="/about">关于|About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:huzongzhe.cn">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/01/【转】计算机操作系统/" title="【转】计算机操作系统" itemprop="url">【转】计算机操作系统</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="奔跑的小河" target="_blank" itemprop="author">奔跑的小河</a>
		
  <p class="article-time">
    <time datetime="2017-03-01T03:12:22.000Z" itemprop="datePublished"> 发表于 2017-03-01</time>
    
  </p>
</header>
	<div class="article-content">
		
		<!-- GFM-TOC -->
<ul>
<li><a href="#第一章-概述">第一章 概述</a><ul>
<li><a href="#操作系统基本特征">操作系统基本特征</a><ul>
<li><a href="#1-并发">1. 并发</a></li>
<li><a href="#2-共享">2. 共享</a></li>
<li><a href="#3-虚拟">3. 虚拟</a></li>
<li><a href="#4-异步">4. 异步</a></li>
</ul>
</li>
<li><a href="#系统调用">系统调用</a></li>
<li><a href="#中断分类">中断分类</a><ul>
<li><a href="#1-外中断">1. 外中断</a></li>
<li><a href="#2-异常">2. 异常</a></li>
<li><a href="#3-陷入">3. 陷入</a></li>
</ul>
</li>
<li><a href="#大内核和微内核">大内核和微内核</a><ul>
<li><a href="#1-大内核">1. 大内核</a></li>
<li><a href="#2-微内核">2. 微内核</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#第二章-进程管理">第二章 进程管理</a><ul>
<li><a href="#进程与线程">进程与线程</a><ul>
<li><a href="#1-进程">1. 进程</a></li>
<li><a href="#2-线程">2. 线程</a></li>
<li><a href="#3-区别">3. 区别</a></li>
</ul>
</li>
<li><a href="#进程状态的切换">进程状态的切换</a></li>
<li><a href="#调度算法">调度算法</a><ul>
<li><a href="#1-批处理系统中的调度">1. 批处理系统中的调度</a><ul>
<li><a href="#11-先来先服务">1.1 先来先服务</a></li>
<li><a href="#12-短作业优先">1.2 短作业优先</a></li>
<li><a href="#13-最短剩余时间优先">1.3 最短剩余时间优先</a></li>
</ul>
</li>
<li><a href="#2-交互式系统中的调度">2. 交互式系统中的调度</a><ul>
<li><a href="#21-优先权优先">2.1 优先权优先</a></li>
<li><a href="#22-时间片轮转">2.2 时间片轮转</a></li>
<li><a href="#23-多级反馈队列">2.3 多级反馈队列</a></li>
<li><a href="#24-短进程优先">2.4 短进程优先</a></li>
</ul>
</li>
<li><a href="#3-实时系统中的调度">3. 实时系统中的调度</a></li>
</ul>
</li>
<li><a href="#进程同步">进程同步</a><ul>
<li><a href="#1-临界区">1. 临界区</a></li>
<li><a href="#2-同步与互斥">2. 同步与互斥</a></li>
<li><a href="#3-信号量">3. 信号量</a></li>
<li><a href="#4-管程">4. 管程</a></li>
</ul>
</li>
<li><a href="#进程通信">进程通信</a><ul>
<li><a href="#1-管道">1. 管道</a></li>
<li><a href="#2-信号量">2. 信号量</a></li>
<li><a href="#3-消息队列">3. 消息队列</a></li>
<li><a href="#4-信号">4. 信号</a></li>
<li><a href="#5-共享内存">5. 共享内存</a></li>
<li><a href="#6-套接字">6. 套接字</a></li>
</ul>
</li>
<li><a href="#经典同步问题">经典同步问题</a><ul>
<li><a href="#1-读者-写者问题">1. 读者-写者问题</a></li>
<li><a href="#2-哲学家进餐问题">2. 哲学家进餐问题</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#第三章-死锁">第三章 死锁</a><ul>
<li><a href="#死锁的必要条件">死锁的必要条件</a></li>
<li><a href="#死锁的处理方法">死锁的处理方法</a><ul>
<li><a href="#1-鸵鸟策略">1. 鸵鸟策略</a></li>
<li><a href="#2-死锁预防">2. 死锁预防</a><ul>
<li><a href="#21-破坏互斥条件">2.1 破坏互斥条件</a></li>
<li><a href="#22-破坏占有和等待条件">2.2 破坏占有和等待条件</a></li>
<li><a href="#23-破坏不可抢占条件">2.3 破坏不可抢占条件</a></li>
<li><a href="#24-破坏环路等待">2.4 破坏环路等待</a></li>
</ul>
</li>
<li><a href="#3-死锁避免">3. 死锁避免</a><ul>
<li><a href="#31-安全状态">3.1 安全状态</a></li>
<li><a href="#32-单个资源的银行家算法">3.2 单个资源的银行家算法</a></li>
<li><a href="#33-多个资源的银行家算法">3.3 多个资源的银行家算法</a></li>
</ul>
</li>
<li><a href="#4-死锁检测与死锁恢复">4. 死锁检测与死锁恢复</a><ul>
<li><a href="#41-死锁检测算法">4.1 死锁检测算法</a></li>
<li><a href="#42-死锁恢复">4.2 死锁恢复</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#第四章-存储器管理">第四章 存储器管理</a><ul>
<li><a href="#虚拟内存">虚拟内存</a></li>
<li><a href="#分页与分段">分页与分段</a><ul>
<li><a href="#1-分页">1. 分页</a></li>
<li><a href="#2-分段">2. 分段</a></li>
<li><a href="#3-段页式">3. 段页式</a></li>
<li><a href="#4-分页与分段区别">4. 分页与分段区别</a></li>
</ul>
</li>
<li><a href="#页面置换算法">页面置换算法</a><ul>
<li><a href="#1-最佳optimal">1. 最佳（Optimal）</a></li>
<li><a href="#2-先进先出fifo">2. 先进先出（FIFO）</a></li>
<li><a href="#3-最近最久未使用lru,-least-recently-used">3. 最近最久未使用（LRU, Least Recently Used）</a></li>
<li><a href="#4-时钟clock">4. 时钟（Clock）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#第五章-设备管理">第五章 设备管理</a><ul>
<li><a href="#磁盘调度算法">磁盘调度算法</a><ul>
<li><a href="#1-先来先服务fcfs,-first-come-first-serverd">1. 先来先服务（FCFS, First Come First Serverd）</a></li>
<li><a href="#2-最短寻道时间优先sstf,-shortest-seek-time-first">2. 最短寻道时间优先（SSTF, Shortest Seek Time First）</a></li>
<li><a href="#3-扫描算法scan">3. 扫描算法（SCAN）</a></li>
<li><a href="#4-循环扫描算法cscan">4. 循环扫描算法（CSCAN）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a><!-- GFM-TOC -->
</li>
</ul>
<p><strong>前言：</strong>关于计算机操作系统的系统知识，个人感觉总结的非常好，故转！其中，愚人对某些部分进行了修改和补充。<br>转自：<a href="https://github.com/CyC2018/Interview-Notebook" target="_blank" rel="noopener">https://github.com/CyC2018/Interview-Notebook</a></p>
<h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1. 并发"></a>1. 并发</h3><p>并发性是指宏观上在一段时间内能同时运行多个程序，而并行性则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线或者多处理器。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2. 共享"></a>2. 共享</h3><p>共享是指系统中的资源可以供多个并发进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。</p>
<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3. 虚拟"></a>3. 虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。</p>
<p>主要有两种虚拟技术：时分复用技术和空分复用技术。例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。</p>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4. 异步"></a>4. 异步</h3><p>异步是指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要用到操作系统的一些功能，就需要使用系统调用从而陷入内核，由操作系统代为完成。</p>
<p>可以由系统调用请求的功能有设备管理、文件管理、进程管理、进程通信、存储器管理等。</p>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="1-外中断"><a href="#1-外中断" class="headerlink" title="1. 外中断"></a>1. 外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<h3 id="2-异常"><a href="#2-异常" class="headerlink" title="2. 异常"></a>2. 异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h3 id="3-陷入"><a href="#3-陷入" class="headerlink" title="3. 陷入"></a>3. 陷入</h3><p>在用户程序中使用系统调用。</p>
<h2 id="大内核和微内核"><a href="#大内核和微内核" class="headerlink" title="大内核和微内核"></a>大内核和微内核</h2><h3 id="1-大内核"><a href="#1-大内核" class="headerlink" title="1. 大内核"></a>1. 大内核</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核。</p>
<p>由于各模块共享信息，因此有很高的性能。</p>
<h3 id="2-微内核"><a href="#2-微内核" class="headerlink" title="2. 微内核"></a>2. 微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。</p>
<p>因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。</p>
<h1 id="第二章-进程管理"><a href="#第二章-进程管理" class="headerlink" title="第二章 进程管理"></a>第二章 进程管理</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h3><p>进程是操作系统进行资源分配的基本单位。</p>
<p>进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。</p>
<h3 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h3><p>一个进程中可以有多个线程，线程是独立调度的基本单位。</p>
<p>同一个进程中的多个线程之间可以并发执行，它们共享进程资源。</p>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a>3. 区别</h3><ul>
<li><p>拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。</p>
</li>
<li><p>调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。</p>
</li>
<li><p>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。</p>
</li>
<li><p>通信方面：进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读/写同一进程中的数据段（如全局变量）来进行通信。</p>
</li>
</ul>
<p>举例：QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。</p>
<h2 id="进程状态的切换"><a href="#进程状态的切换" class="headerlink" title="进程状态的切换"></a>进程状态的切换</h2><p><img src="/images/1706ce58-a081-4fed-9b36-c3c0d7e22b3a.jpg" alt=""></p>
<p>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU，缺少 CPU 会让进程从运行态转换为就绪态。</p>
<p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p>需要针对不同环境来讨论调度算法。</p>
<h3 id="1-批处理系统中的调度"><a href="#1-批处理系统中的调度" class="headerlink" title="1. 批处理系统中的调度"></a>1. 批处理系统中的调度</h3><h4 id="1-1-先来先服务"><a href="#1-1-先来先服务" class="headerlink" title="1.1 先来先服务"></a>1.1 先来先服务</h4><p>first-come first-serverd（FCFS）。</p>
<p>调度最先进入就绪队列的作业。</p>
<p>有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。</p>
<h4 id="1-2-短作业优先"><a href="#1-2-短作业优先" class="headerlink" title="1.2 短作业优先"></a>1.2 短作业优先</h4><p>shortest job first（SJF）。</p>
<p>调度估计运行时间最短的作业。</p>
<p>长作业有可能会饿死，处于一直等待短作业执行完毕的状态。如果一直有短作业到来，那么长作业永远得不到调度。</p>
<h4 id="1-3-最短剩余时间优先"><a href="#1-3-最短剩余时间优先" class="headerlink" title="1.3 最短剩余时间优先"></a>1.3 最短剩余时间优先</h4><p>shortest remaining time next（SRTN）。</p>
<h3 id="2-交互式系统中的调度"><a href="#2-交互式系统中的调度" class="headerlink" title="2. 交互式系统中的调度"></a>2. 交互式系统中的调度</h3><h4 id="2-1-优先权优先"><a href="#2-1-优先权优先" class="headerlink" title="2.1 优先权优先"></a>2.1 优先权优先</h4><p>除了可以手动赋予优先权之外，还可以把响应比作为优先权，这种调度方式叫做高响应比优先调度算法。</p>
<p>响应比 = (等待时间 + 要求服务时间) / 要求服务时间 = 响应时间 / 要求服务时间</p>
<p>这种调度算法主要是为了解决 SJF 中长作业可能会饿死的问题，因为随着等待时间的增长，响应比也会越来越高。</p>
<h4 id="2-2-时间片轮转"><a href="#2-2-时间片轮转" class="headerlink" title="2.2 时间片轮转"></a>2.2 时间片轮转</h4><p>将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 分配给队首的进程。</p>
<p>时间片轮转算法的效率和时间片的大小有很大关系。因为每次进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，进程切换太频繁，在进程切换上就会花过多时间。</p>
<h4 id="2-3-多级反馈队列"><a href="#2-3-多级反馈队列" class="headerlink" title="2.3 多级反馈队列"></a>2.3 多级反馈队列</h4><p><img src="/images/042cf928-3c8e-4815-ae9c-f2780202c68f.png" alt=""></p>
<ol>
<li><p>设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权越高的队列中，为每个进程所规定的执行时间片就越小。</p>
</li>
<li><p>当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入下一个队列的队尾。</p>
</li>
<li><p>仅当前 i-1 个队列均空时，才会调度第 i 个队列中的进程。</p>
</li>
</ol>
<p>优点：实时性好，同时适合运行短作业和长作业。</p>
<h4 id="2-4-短进程优先"><a href="#2-4-短进程优先" class="headerlink" title="2.4 短进程优先"></a>2.4 短进程优先</h4><h3 id="3-实时系统中的调度"><a href="#3-实时系统中的调度" class="headerlink" title="3. 实时系统中的调度"></a>3. 实时系统中的调度</h3><p>实时系统要求一个服务请求在一个确定时间内得到响应。</p>
<p>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。</p>
<p>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// entry section</span><br><span class="line">// critical section;</span><br><span class="line">// exit section</span><br></pre></td></tr></table></figure>
<h3 id="2-同步与互斥"><a href="#2-同步与互斥" class="headerlink" title="2. 同步与互斥"></a>2. 同步与互斥</h3><ul>
<li>同步指多个进程按一定顺序执行；</li>
<li>互斥指多个进程在同一时刻只有一个进程能进入临界区。</li>
</ul>
<h3 id="3-信号量"><a href="#3-信号量" class="headerlink" title="3. 信号量"></a>3. 信号量</h3><p><strong>信号量（Semaphore）</strong>  是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。</p>
<ul>
<li><strong>down</strong>  : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，将进程睡眠，等待信号量大于 0；</li>
<li><strong>up</strong> ：对信号量执行 +1 操作，并且唤醒睡眠的进程，让进程完成 down 操作。</li>
</ul>
<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>
<p>如果信号量的取值只能为 0 或者 1，那么就成为了  <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    down(mutex);</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">    up(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用信号量实现生产者-消费者问题</strong> </p>
<p>使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。</p>
<p>需要使用一个互斥量 mutex 来对缓冲区这个临界资源进行互斥访问。</p>
<p>为了控制生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进行中使用，当 full 信号量不为 0 时，消费者才可以取走物品。</p>
<p>注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty=0，此时生成者睡眠。消费者此时不能进入临界区，因为生产者对缓冲区加锁了，也就无法执行 up(empty) 操作，那么生产者和消费者就会一直等待下去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">semaphore empty = N;</span><br><span class="line">semaphore full = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        <span class="keyword">int</span> item = produce_item;</span><br><span class="line">        down(empty);</span><br><span class="line">        down(mutex);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        up(mutex);</span><br><span class="line">        up(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">        down(full);</span><br><span class="line">        down(mutex);</span><br><span class="line">        <span class="keyword">int</span> item = remove_item(item);</span><br><span class="line">        up(mutex);</span><br><span class="line">        up(empty);</span><br><span class="line">        consume_item(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-管程"><a href="#4-管程" class="headerlink" title="4. 管程"></a>4. 管程</h3><p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>
<p>c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码中的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    integer i;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">remove</span><span class="params">()</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br></pre></td></tr></table></figure>
<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。</p>
<p>管程引入了  <strong>条件变量</strong>  以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来让另一个进程持有。signal() 操作用于唤醒被阻塞的进程。</p>
<p><strong>使用管程实现生成者-消费者问题</strong> </p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer</span><br><span class="line">    condition full, empty;</span><br><span class="line">    integer count := <span class="number">0</span>;</span><br><span class="line">    condition c;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">insert</span><span class="params">(item: integer)</span>;</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = N <span class="keyword">then</span> wait(full);</span><br><span class="line">        insert_item(item);</span><br><span class="line">        count := count + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">1</span> <span class="keyword">then</span> signal(empty);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">remove</span>:</span> integer;</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> count = <span class="number">0</span> <span class="keyword">then</span> wait(empty);</span><br><span class="line">        remove = remove_item;</span><br><span class="line">        count := count - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> count = N -<span class="number">1</span> <span class="keyword">then</span> signal(full);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">end</span> monitor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">producer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">produce_item</span>;</span></span><br><span class="line">        ProducerConsumer.insert(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">consumer</span></span></span><br><span class="line"><span class="function"><span class="title">begin</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span> <span class="title">true</span> <span class="title">do</span></span></span><br><span class="line"><span class="function">    <span class="title">begin</span></span></span><br><span class="line"><span class="function">        <span class="title">item</span> = <span class="title">ProducerConsumer</span>.<span class="title">remove</span>;</span></span><br><span class="line">        consume_item(item);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程通信可以看成是不同进程间的线程通信，对于同一个进程内线程的通信方式，主要使用信号量、条件变量等同步机制。</p>
<h3 id="1-管道"><a href="#1-管道" class="headerlink" title="1. 管道"></a>1. 管道</h3><p>管道是单向的、先进先出的、无结构的、固定大小的字节流，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的首端读出数据。数据读出后将从管道中移走，其它读进程都不能再读到这些数据。</p>
<p>管道提供了简单的流控制机制，进程试图读空管道时，在有数据写入管道前，进程将一直阻塞。同样地，管道已经满时，进程再试图写管道，在其它进程从管道中移走数据之前，写进程将一直阻塞。</p>
<p>Linux 中管道是通过空文件来实现。</p>
<p>管道有三种：</p>
<ol>
<li>普通管道：这种通讯方式有两种限制，第一是半双工的通信，数据只能单向流动，第二是只能在父子进程间使用。</li>
<li>流管道：去除第一个限制，支持双向传输；</li>
<li>命名管道：去除第二个限制，可以在不相关进程之间进行通信。</li>
</ol>
<p>共同缺点:是速度慢，容量有限</p>
<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h3><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h3 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3. 消息队列"></a>3. 消息队列</h3><p>消息队列是由消息的链表(Posix消息队列system V消息队列)，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h3 id="4-信号"><a href="#4-信号" class="headerlink" title="4. 信号"></a>4. 信号</h3><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。如<code>Ctrl+c</code>,<code>kill -9 &lt;pid&gt;</code></p>
<h3 id="5-共享内存"><a href="#5-共享内存" class="headerlink" title="5. 共享内存"></a>5. 共享内存</h3><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<br>共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用，来实现进程间的同步和互斥通信。</p>
<h3 id="6-套接字"><a href="#6-套接字" class="headerlink" title="6. 套接字"></a>6. 套接字</h3><p>套接字也是一种进程间通信机制，与其它通信机制不同的是，它可用于不同机器间的进程通信。其中域套接字可以用于同机器的进程间通信！</p>
<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><p>生产者和消费者问题前面已经讨论过了。</p>
<h3 id="1-读者-写者问题"><a href="#1-读者-写者问题" class="headerlink" title="1. 读者-写者问题"></a>1. 读者-写者问题</h3><p>允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。</p>
<p>一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore count_mutex = <span class="number">1</span>;</span><br><span class="line">semaphore data_mutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(count_mutex);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>) down(data_mutex); <span class="comment">// 第一个读者需要对数据进行加锁，防止写进程访问</span></span><br><span class="line">        up(count_mutex);</span><br><span class="line">        read();</span><br><span class="line">        down(count_mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>) up(data_mutex);</span><br><span class="line">        up(count_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        down(data_mutex);</span><br><span class="line">        write();</span><br><span class="line">        up(data_mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-哲学家进餐问题"><a href="#2-哲学家进餐问题" class="headerlink" title="2. 哲学家进餐问题"></a>2. 哲学家进餐问题</h3><p><img src="/images/a9077f06-7584-4f2b-8c20-3a8e46928820.jpg" alt=""></p>
<p>五个哲学家围着一张圆周，每个哲学家面前放着饭。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先一根一根拿起左右两边的筷子。</p>
<p>下面是一种错误的解法，考虑到如果每个哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEFT (i + N - 1) % N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RIGHT (i + N) % N</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> semaphore;</span><br><span class="line">semaphore chopstick[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TURE)&#123;</span><br><span class="line">        think();</span><br><span class="line">        down(chopstick[LEFT[i]]);</span><br><span class="line">        down(chopstick[RIGHT[i]]);</span><br><span class="line">        eat();</span><br><span class="line">        up(chopstick[RIGHT[i]]);</span><br><span class="line">        up(chopstick[LEFT[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了防止死锁的发生，可以加一点限制，只允许同时拿起左右两边的筷子。方法是引入一个互斥量，对拿起两个筷子的那段代码加锁。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TURE)&#123;</span><br><span class="line">        think();</span><br><span class="line">        down(mutex);</span><br><span class="line">        down(chopstick[LEFT[i]]);</span><br><span class="line">        down(chopstick[RIGHT[i]]);</span><br><span class="line">        up(mutex);</span><br><span class="line">        eat();</span><br><span class="line">        down(mutex);</span><br><span class="line">        up(chopstick[RIGHT[i]]);</span><br><span class="line">        up(chopstick[LEFT[i]]);</span><br><span class="line">        up(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第三章-死锁"><a href="#第三章-死锁" class="headerlink" title="第三章 死锁"></a>第三章 死锁</h1><h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><p><img src="/images/c037c901-7eae-4e31-a1e4-9d41329e5c3e.png" alt=""></p>
<ol>
<li>互斥：每个资源要么已经分配给了一个进程，要么就是可用的。即一个资源只能被一个进程独占。</li>
<li>占有和等待：已经得到了某个资源的进程可以再请求新的资源。</li>
<li>不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显示地释放。</li>
<li>环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。</li>
</ol>
<h2 id="死锁的处理方法"><a href="#死锁的处理方法" class="headerlink" title="死锁的处理方法"></a>死锁的处理方法</h2><h3 id="1-鸵鸟策略"><a href="#1-鸵鸟策略" class="headerlink" title="1. 鸵鸟策略"></a>1. 鸵鸟策略</h3><p>把头埋在沙子里，假装根本没发生问题。</p>
<p>这种策略不可取。</p>
<h3 id="2-死锁预防"><a href="#2-死锁预防" class="headerlink" title="2. 死锁预防"></a>2. 死锁预防</h3><p>在程序运行之前预防发生死锁。</p>
<h4 id="2-1-破坏互斥条件"><a href="#2-1-破坏互斥条件" class="headerlink" title="2.1 破坏互斥条件"></a>2.1 破坏互斥条件</h4><p>例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。</p>
<h4 id="2-2-破坏占有和等待条件"><a href="#2-2-破坏占有和等待条件" class="headerlink" title="2.2 破坏占有和等待条件"></a>2.2 破坏占有和等待条件</h4><p>一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。</p>
<h4 id="2-3-破坏不可抢占条件"><a href="#2-3-破坏不可抢占条件" class="headerlink" title="2.3 破坏不可抢占条件"></a>2.3 破坏不可抢占条件</h4><h4 id="2-4-破坏环路等待"><a href="#2-4-破坏环路等待" class="headerlink" title="2.4 破坏环路等待"></a>2.4 破坏环路等待</h4><p>给资源统一编号，进程只能按编号顺序来请求资源。</p>
<h3 id="3-死锁避免"><a href="#3-死锁避免" class="headerlink" title="3. 死锁避免"></a>3. 死锁避免</h3><p>在程序运行时避免发生死锁。</p>
<h4 id="3-1-安全状态"><a href="#3-1-安全状态" class="headerlink" title="3.1 安全状态"></a>3.1 安全状态</h4><p><img src="/images/ed523051-608f-4c3f-b343-383e2d194470.png" alt=""></p>
<p>图 a 的第二列 has 表示已拥有的资源数，第三列 max 表示总共需要的资源数，free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源，运行结束后释放 B，此时 free 变为 4；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。</p>
<p>定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。</p>
<h4 id="3-2-单个资源的银行家算法"><a href="#3-2-单个资源的银行家算法" class="headerlink" title="3.2 单个资源的银行家算法"></a>3.2 单个资源的银行家算法</h4><p>一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。</p>
<p><img src="/images/d160ec2e-cfe2-4640-bda7-62f53e58b8c0.png" alt=""></p>
<p>上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。</p>
<h4 id="3-3-多个资源的银行家算法"><a href="#3-3-多个资源的银行家算法" class="headerlink" title="3.3 多个资源的银行家算法"></a>3.3 多个资源的银行家算法</h4><p><img src="/images/62e0dd4f-44c3-43ee-bb6e-fedb9e068519.png" alt=""></p>
<p>上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A=(1020)，表示 4 个资源分别还剩下 1/0/2/0。</p>
<p>检查一个状态是否安全的算法如下：</p>
<ul>
<li>查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。</li>
<li>假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。</li>
<li>重复以上两步，直到所有进程都标记为终止，则状态时安全的。</li>
</ul>
<h3 id="4-死锁检测与死锁恢复"><a href="#4-死锁检测与死锁恢复" class="headerlink" title="4. 死锁检测与死锁恢复"></a>4. 死锁检测与死锁恢复</h3><p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>
<h4 id="4-1-死锁检测算法"><a href="#4-1-死锁检测算法" class="headerlink" title="4.1 死锁检测算法"></a>4.1 死锁检测算法</h4><p>死锁检测的基本思想是，如果一个进程所请求的资源能够被满足，那么就让它执行，释放它拥有的所有资源，然后让其它能满足条件的进程执行。</p>
<p><img src="/images/e1eda3d5-5ec8-4708-8e25-1a04c5e11f48.png" alt=""></p>
<p>上图中，有三个进程四个资源，每个数据代表的含义如下：</p>
<ul>
<li>E 向量：资源总量</li>
<li>A 向量：资源剩余量</li>
<li>C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量</li>
<li>R 矩阵：每个进程请求的资源数量</li>
</ul>
<p>进程 P<sub>1</sub> 和 P<sub>2</sub> 所请求的资源都得不到满足，只有进程 P<sub>3</sub> 可以，让 P<sub>3</sub> 执行，之后释放 P<sub>3</sub> 拥有的资源，此时 A = (2 2 2 0)。P<sub>1</sub> 可以执行，执行后释放 P<sub>1</sub> 拥有的资源，A = (4 2 2 2) ，P<sub>2</sub> 也可以执行。所有进程都可以顺利执行，没有死锁。</p>
<p>算法总结如下：</p>
<p>每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。</p>
<ol>
<li>寻找一个没有标记的进程 P<sub>i</sub>，它所请求的资源小于等于 A。</li>
<li>如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。</li>
<li>如果有没有这样一个进程，算法终止。</li>
</ol>
<p>可以看到，死锁检测和银行家算法中判断是否为安全状态的方法类似。</p>
<h4 id="4-2-死锁恢复"><a href="#4-2-死锁恢复" class="headerlink" title="4.2 死锁恢复"></a>4.2 死锁恢复</h4><ul>
<li>利用抢占恢复</li>
<li>杀死进程</li>
</ul>
<h1 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</p>
<p>当程序引用到一部分在物理内存中的地址空间时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。</p>
<h2 id="分页与分段"><a href="#分页与分段" class="headerlink" title="分页与分段"></a>分页与分段</h2><h3 id="1-分页"><a href="#1-分页" class="headerlink" title="1. 分页"></a>1. 分页</h3><p>用户程序的地址空间被划分为若干固定大小的区域，称为“页”。相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配，由一个页表来维护它们之间的映射关系。</p>
<h3 id="2-分段"><a href="#2-分段" class="headerlink" title="2. 分段"></a>2. 分段</h3><p><img src="/images/22de0538-7c6e-4365-bd3b-8ce3c5900216.png" alt=""></p>
<p>上图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态递增的特点会导致覆盖问题的出现。</p>
<p><img src="/images/e0900bb2-220a-43b7-9aa9-1d5cd55ff56e.png" alt=""></p>
<p>分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。</p>
<p>每个段都需要程序员来划分。</p>
<h3 id="3-段页式"><a href="#3-段页式" class="headerlink" title="3. 段页式"></a>3. 段页式</h3><p>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。</p>
<p>用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。</p>
<p>程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护。</p>
<h3 id="4-分页与分段区别"><a href="#4-分页与分段区别" class="headerlink" title="4. 分页与分段区别"></a>4. 分页与分段区别</h3><ul>
<li><p>对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。</p>
</li>
<li><p>地址空间的维度：分页是一维地址空间，分段是二维的。</p>
</li>
<li><p>大小是否可以改变：页的大小不可变，段的大小可以动态改变。</p>
</li>
<li><p>出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p>
</li>
</ul>
<h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p>在程序运行过程中，若其所要访问的页面不在内存而需要把它们调入内存，但是内存已无空闲空间时，系统必须从内存中调出一个页面到磁盘对换区中，并且将程序所需要的页面调入内存中。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。</p>
<h3 id="1-最佳（Optimal）"><a href="#1-最佳（Optimal）" class="headerlink" title="1. 最佳（Optimal）"></a>1. 最佳（Optimal）</h3><p>所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。</p>
<p>是一种理论上的算法，因为无法知道一个页面多长时间会被再访问到。</p>
<h3 id="2-先进先出（FIFO）"><a href="#2-先进先出（FIFO）" class="headerlink" title="2. 先进先出（FIFO）"></a>2. 先进先出（FIFO）</h3><p>所选择换出的页面是最先进入的页面。</p>
<p>该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。</p>
<h3 id="3-最近最久未使用（LRU-Least-Recently-Used）"><a href="#3-最近最久未使用（LRU-Least-Recently-Used）" class="headerlink" title="3. 最近最久未使用（LRU, Least Recently Used）"></a>3. 最近最久未使用（LRU, Least Recently Used）</h3><p>虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。</p>
<p>可以用栈来实现该算法，栈中存储页面的页面号。当进程访问一个页面时，将该页面的页面号从栈移除，并将它压入栈顶。这样，最近被访问的页面的页面号总是在栈顶，而最近最久未使用的页面的页面号总是在栈底。</p>
<p><img src="/images/eb859228-c0f2-4bce-910d-d9f76929352b.png" alt=""></p>
<h3 id="4-时钟（Clock）"><a href="#4-时钟（Clock）" class="headerlink" title="4. 时钟（Clock）"></a>4. 时钟（Clock）</h3><p>Clock 页面置换算法需要用到一个访问位，当一个页面被访问时，将访问位置为 1。</p>
<p>首先，将内存中的所有页面链接成一个循环队列，当缺页中断发生时，检查当前指针所指向页面的访问位，如果访问位为 0，就将该页面换出；否则将该页的访问位设置为 0，给该页面第二次的机会，移动指针继续检查。</p>
<h1 id="第五章-设备管理"><a href="#第五章-设备管理" class="headerlink" title="第五章 设备管理"></a>第五章 设备管理</h1><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>当多个进程同时请求访问磁盘时，需要进行磁盘调度来控制对磁盘的访问。磁盘调度的主要目标是使磁盘的平均寻道时间最少。</p>
<h3 id="1-先来先服务（FCFS-First-Come-First-Serverd）"><a href="#1-先来先服务（FCFS-First-Come-First-Serverd）" class="headerlink" title="1. 先来先服务（FCFS, First Come First Serverd）"></a>1. 先来先服务（FCFS, First Come First Serverd）</h3><p>根据进程请求访问磁盘的先后次序来进行调度。优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>
<h3 id="2-最短寻道时间优先（SSTF-Shortest-Seek-Time-First）"><a href="#2-最短寻道时间优先（SSTF-Shortest-Seek-Time-First）" class="headerlink" title="2. 最短寻道时间优先（SSTF, Shortest Seek Time First）"></a>2. 最短寻道时间优先（SSTF, Shortest Seek Time First）</h3><p>要求访问的磁道与当前磁头所在磁道距离最近的优先进行调度。这种算法并不能保证平均寻道时间最短，但是比 FCFS 好很多。</p>
<h3 id="3-扫描算法（SCAN）"><a href="#3-扫描算法（SCAN）" class="headerlink" title="3. 扫描算法（SCAN）"></a>3. 扫描算法（SCAN）</h3><p>SSTF 会出现饥饿现象。考虑以下情况，新进程请求访问的磁道与磁头所在磁道的距离总是比一个在等待的进程来的近，那么等待的进程会一直等待下去。</p>
<p>SCAN 算法在 SSTF 算法之上考虑了磁头的移动方向，要求所请求访问的磁道在磁头当前移动方向上才能够得到调度。因为考虑了移动方向，那么一个进程请求访问的磁道一定会得到调度。</p>
<p>当一个磁头自里向外移动时，移到最外侧会改变移动方向为自外向里，这种移动的规律类似于电梯的运行，因此又常称 SCAN 算法为电梯调度算法。</p>
<h3 id="4-循环扫描算法（CSCAN）"><a href="#4-循环扫描算法（CSCAN）" class="headerlink" title="4. 循环扫描算法（CSCAN）"></a>4. 循环扫描算法（CSCAN）</h3><p>CSCAN 对 SCAN 进行了改动，要求磁头始终沿着一个方向移动。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014.</li>
<li>汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001.</li>
<li>Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统.</li>
<li><a href="http://blog.csdn.net/yufaw/article/details/7409596" target="_blank" rel="noopener">进程间的几种通信方式</a></li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/计算机操作系统/">计算机操作系统</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/操作系统/">操作系统</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://huzongzhe.cn/2017/03/01/【转】计算机操作系统/" data-title="【转】计算机操作系统 | running river" data-tsina="" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2017/03/08/JVM实用参数整理/" title="JVM实用参数整理">
  <strong>上一篇：</strong><br/>
  <span>
  JVM实用参数整理</span>
</a>
</div>


<div class="next">
<a href="/2016/11/12/【Linux】cron，at，batch(任务调度)/"  title="【Linux】cron，at，batch(任务调度)">
 <strong>下一篇：</strong><br/> 
 <span>【Linux】cron，at，batch(任务调度)
</span>
</a>
</div>

</nav>

	



</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/ActiveMQ/" title="ActiveMQ">ActiveMQ<sup>10</sup></a></li>
		  
		
		  
			<li><a href="/categories/Guava/" title="Guava">Guava<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/HBase/" title="HBase">HBase<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/HttpClient/" title="HttpClient">HttpClient<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>6</sup></a></li>
		  
		
		  
			<li><a href="/categories/Ubuntu/" title="Ubuntu">Ubuntu<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/java/" title="java">java<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/mysql/" title="mysql">mysql<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/shell/" title="shell">shell<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/zookeeper/" title="zookeeper">zookeeper<sup>4</sup></a></li>
		  
		
		  
			<li><a href="/categories/教程/" title="教程">教程<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/数据结构/" title="数据结构">数据结构<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/计算机操作系统/" title="计算机操作系统">计算机操作系统<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/ActiveMQ/" title="ActiveMQ">ActiveMQ<sup>10</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/HBase/" title="HBase">HBase<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/zookeeper/" title="zookeeper">zookeeper<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/JVM/" title="JVM">JVM<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/mysql/" title="mysql">mysql<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/开发工具/" title="开发工具">开发工具<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Guava/" title="Guava">Guava<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/shell/" title="shell">shell<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/synchronized/" title="synchronized">synchronized<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HttpClient/" title="HttpClient">HttpClient<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/volatile/" title="volatile">volatile<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/bitMap/" title="bitMap">bitMap<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/bloomFilter/" title="bloomFilter">bloomFilter<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hexo-jacman/" title="hexo jacman">hexo jacman<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Ubuntu/" title="Ubuntu">Ubuntu<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/hive/" title="hive">hive<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/mongo/" title="mongo">mongo<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/runingriver" target="_blank" title="Github你值得拥有">github</a>
            
          </li>
        
          <li>
            
            	<a href="http://blog.csdn.net/z702143700" target="_blank" title="国内常用博客平台">CSDN</a>
            
          </li>
        
          <li>
            
            	<a href="http://ifeve.com" target="_blank" title="并发编程网">并发编程网</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.importnew.com/" target="_blank" title="importnew">importnew</a>
            
          </li>
        
          <li>
            
            	<a href="https://coolshell.cn/" target="_blank" title="酷壳">酷壳</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.tuicool.com/a/" target="_blank" title="推酷">推酷</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.v2ex.com/" target="_blank" title="V2ex">V2ex</a>
            
          </li>
        
    </ul>
</div>

  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 订阅</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Talk is cheap,show me your code.  <br/>
			life is like running river.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/runingriver" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		
		
		<a href="mailto:huzongzhe@126.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="奔跑的小河">奔跑的小河</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>











<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
